# 使用示例

<cite>
**本文档中引用的文件**  
- [lib.rs](file://src/lib.rs)
- [base.rs](file://src/base.rs)
- [README.md](file://README.md)
</cite>

## 目录
1. [全局静态自旋锁变量初始化](#全局静态自旋锁变量初始化)  
2. [中断处理程序中的SpinNoIrq<T>使用](#中断处理程序中的spinnoirqt使用)  
3. [内核线程中的SpinNoPreempt<T>使用](#内核线程中的spinnopreemptt使用)  
4. [低层级同步的SpinRaw<T>使用](#低层级同步的spinrawt使用)  
5. [最佳实践建议](#最佳实践建议)

## 全局静态自旋锁变量初始化

使用 `lazy_static` 或 `const` 初始化全局静态自旋锁变量是确保多线程环境中安全共享数据的关键步骤。通过 `SpinRaw::new()` 可创建无需改变CPU状态的原始自旋锁，适用于已禁用抢占和中断的上下文。

```rust
use kspin::SpinRaw;
use lazy_static::lazy_static;

// 使用 lazy_static 宏延迟初始化全局自旋锁
lazy_static! {
    static ref GLOBAL_COUNTER: SpinRaw<u32> = SpinRaw::new(0);
}
```

此方法保证了在首次访问时才进行初始化，并且在整个程序生命周期内保持有效。结合 `const fn new(data: T) -> Self` 的零成本构造特性，适合用于内核空间的静态资源管理。

**Section sources**
- [lib.rs](file://src/lib.rs#L21-L35)
- [base.rs](file://src/base.rs#L44-L68)

## 中断处理程序中的SpinNoIrq<T>使用

在中断处理程序中，必须使用 `SpinNoIrq<T>` 来保护共享状态，因为它会自动禁用本地中断并防止竞争条件。该锁类型基于 `BaseSpinLock<NoPreemptIrqSave, T>` 实现，在加锁期间关闭IRQ，解锁后恢复原状态。

```rust
use kspin::SpinNoIrq;

// 声明一个用于中断上下文的共享计数器
static INTERRUPT_SAFE_COUNTER: SpinNoIrq<u32> = SpinNoIrq::new(0);

// 在中断服务例程中安全地更新共享数据
fn interrupt_handler() {
    let mut guard = INTERRUPT_SAFE_COUNTER.lock();
    *guard += 1; // 访问受保护的数据
    // 离开作用域时自动释放锁
}
```

`irq_state` 字段保存了中断前的状态，确保在 `Drop` 时正确恢复。这种机制避免了中断嵌套导致的死锁或数据损坏。

**Section sources**
- [lib.rs](file://src/lib.rs#L14-L20)
- [base.rs](file://src/base.rs#L70-L100)
- [base.rs](file://src/base.rs#L218-L275)

## 内核线程中的SpinNoPreempt<T>使用

普通内核线程应使用 `SpinNoPreempt<T>` 防止因调度器抢占引发的竞争条件。此锁类型在获取时禁用内核抢占，仅在单处理器系统上提供基本互斥保障。

```rust
use kspin::SpinNoPreempt;

// 定义一个可在内核线程间共享的安全变量
static SHARED_RESOURCE: SpinNoPreempt<Vec<u8>> = SpinNoPreempt::new(Vec::new());

// 在内核线程中安全操作共享资源
fn kernel_thread_routine() {
    let mut guard = SHARED_RESOURCE.lock();
    guard.push(42); // 修改共享数据
    // 自动释放锁，重新启用抢占
}
```

注意：此类锁不可用于中断上下文，否则可能导致系统挂起。其安全性依赖于正确的上下文使用规则。

**Section sources**
- [lib.rs](file://src/lib.rs#L7-L13)
- [base.rs](file://src/base.rs#L70-L100)
- [base.rs](file://src/base.rs#L218-L275)

## 低层级同步的SpinRaw<T>使用

`SpinRaw<T>` 提供最轻量级的同步原语，不修改任何CPU状态（如抢占或中断），专为已在禁用抢占和中断的上下文中使用而设计。

```rust
use kspin::SpinRaw;

// 创建一个原始自旋锁，用于高度优化的临界区
static RAW_LOCKED_DATA: SpinRaw<u64> = SpinRaw::new(0);

// 在已知安全的上下文中快速访问数据
unsafe fn fast_path_update() {
    let mut guard = RAW_LOCKED_DATA.lock();
    *guard ^= 0xdeadbeef; // 执行位运算更新
    // 锁在作用域结束时自动释放
}
```

由于 `SpinRaw` 不做任何状态管理，调用者必须确保当前执行环境不会被中断或抢占。`unsafe` 块的存在提醒开发者需手动验证上下文安全性。

**Section sources**
- [lib.rs](file://src/lib.rs#L21-L35)
- [base.rs](file://src/base.rs#L70-L100)
- [base.rs](file://src/base.rs#L218-L275)

## 最佳实践建议

为确保高效且安全地使用kspin提供的各类自旋锁，请遵循以下最佳实践：

- **避免长时间持有锁**：自旋锁不适合长时操作，应在临界区内尽量减少计算和I/O。
- **不在锁内执行复杂逻辑**：禁止在持锁期间调用可能阻塞或睡眠的函数。
- **优先使用 try_lock() 进行非阻塞尝试**：当无法确定能否立即获得锁时，使用 `try_lock()` 避免无限等待。
- **明确标注 unsafe 块的目的**：所有 `unsafe` 操作都应附带注释说明为何安全及如何保证内存安全。
- **合理选择锁类型**：根据运行上下文（中断/线程）选择合适的锁变体以最小化性能开销。

这些原则有助于构建稳定、可维护的内核级并发代码。

**Section sources**
- [README.md](file://README.md#L13-L35)
- [base.rs](file://src/base.rs#L102-L135)
- [base.rs](file://src/base.rs#L137-L175)