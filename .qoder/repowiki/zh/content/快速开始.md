<cite>
**本文档中引用的文件**
- [Cargo.toml](file://Cargo.toml)
- [README.md](file://README.md)
- [src/lib.rs](file://src/lib.rs)
- [src/base.rs](file://src/base.rs)
</cite>

# 快速开始

## 目录
1. [简介](#简介)
2. [添加依赖与启用特性](#添加依赖与启用特性)
3. [核心锁类型详解](#核心锁类型详解)
4. [完整代码示例](#完整代码示例)
5. [工作原理深入解析](#工作原理深入解析)
6. [常见错误与最佳实践](#常见错误与最佳实践)

## 简介

`kspin` 是一个专为内核空间设计的自旋锁库，它通过在临界区内禁用抢占或中断（IRQs）来提供互斥访问。本指南将详细介绍如何在Rust内核项目中集成和使用 `kspin`，特别适合刚接触系统级同步原语的新手开发者。

**Section sources**
- [README.md](file://README.md#L1-L10)

## 添加依赖与启用特性

要在您的 `Cargo.toml` 文件中集成 `kspin`，您需要将其作为依赖项添加。此外，根据您的运行环境，可能需要启用特定的功能（feature）。

对于多核（SMP）环境，必须启用 `smp` 特性，这会引入必要的原子操作来协调多个CPU核心对锁的竞争。而在单核环境中，此特性可以省略，以获得更优的性能，因为锁状态会被优化掉。

```toml
[dependencies]
kspin = "0.1.1"

[features]
# 用于多核环境
smp = []
```

**Section sources**
- [Cargo.toml](file://Cargo.toml#L1-L22)

## 核心锁类型详解

`kspin` 提供了三种主要的锁类型，它们的行为由底层的守卫机制决定：

- **`SpinRaw<T>`**: 原始自旋锁，在尝试加锁时不做任何额外操作。它必须在已禁用抢占和本地中断的上下文中使用。
- **`SpinNoPreempt<T>`**: 在加锁时会禁用内核抢占，并在解锁时重新启用。适用于需要防止任务切换但允许中断的场景。
- **`SpinNoIrq<T>`**: 最严格的锁类型，在加锁时同时禁用内核抢占和本地中断，并在解锁时恢复它们。这是最安全的选择，可用于几乎任何上下文。

这些类型都是基于 `BaseSpinLock<G, T>` 的类型别名，其中泛型参数 `G` 决定了具体的保护行为。

**Section sources**
- [src/lib.rs](file://src/lib.rs#L10-L37)
- [src/base.rs](file://src/base.rs#L1-L437)

## 完整代码示例

以下是一个完整的代码示例，展示了如何定义一个共享变量、初始化自旋锁、获取锁并安全地访问受保护的数据。

```rust
use kspin::{SpinNoIrq, SpinNoPreempt, SpinRaw};

// 1. 定义共享数据并初始化不同类型的自旋锁
let data_raw = SpinRaw::new(0u32);
let data_preempt = SpinNoPreempt::new(String::from("Hello"));
let data_irq = SpinNoIrq::new(vec![1, 2, 3]);

// 2. 获取锁并进入临界区
{
    // 使用 lock() 方法获取 SpinRaw 锁
    let mut guard_raw = data_raw.lock();
    // 此时可以安全地修改共享数据
    *guard_raw += 1;
    // guard_raw 在此处离开作用域，自动释放锁
}

{
    // 使用 lock() 方法获取 SpinNoPreempt 锁
    let mut guard_preempt = data_preempt.lock();
    guard_preempt.push_str(" World");
    // guard_preempt 在此处离开作用域，自动释放锁
}

{
    // 使用 lock() 方法获取 SpinNoIrq 锁
    let mut guard_irq = data_irq.lock();
    guard_irq.push(4);
    // guard_irq 在此处离开作用域，自动释放锁
}
```

**Section sources**
- [README.md](file://README.md#L20-L35)
- [src/lib.rs](file://src/lib.rs#L10-L37)

## 工作原理深入解析

### `lock()` 调用的行为

当调用 `lock()` 方法时，会发生一系列关键操作：
1.  **获取守卫状态**：首先调用 `G::acquire()`，例如 `NoPreemptIrqSave::acquire()` 会保存当前的中断状态并禁用中断。
2.  **竞争锁状态（仅限SMP）**：在启用了 `smp` 特性的多核环境中，线程会通过一个循环使用 `compare_exchange_weak` 原子操作来竞争锁。如果失败，它会调用 `core::hint::spin_loop()` 进行短暂等待后重试。
3.  **构造守卫对象**：一旦成功获取锁，就会创建一个 `BaseSpinLockGuard` 对象，该对象持有对数据的可变指针和锁的引用。

### 守卫对象的生命周期管理与自动释放

`kspin` 的核心安全机制在于其守卫（Guard）模式。`lock()` 方法返回的不是一个原始锁，而是一个实现了 `Drop` trait 的 `BaseSpinLockGuard` 类型的守卫对象。

这个守卫对象遵循RAII（Resource Acquisition Is Initialization）原则：
- **获取即初始化**：当 `lock()` 成功返回时，守卫对象被创建，此时锁已被持有。
- **析构即释放**：当守卫对象离开其作用域时，Rust编译器会自动调用其 `drop()` 方法。该方法负责执行两个关键操作：
    - （仅限SMP）通过 `store(false, Ordering::Release)` 将锁状态设置为“未锁定”。
    - 调用 `G::release(irq_state)` 来恢复之前保存的中断/抢占状态。

这种机制确保了即使在发生panic的情况下，锁也能被正确释放，从而避免死锁。

```mermaid
flowchart TD
Start([调用 lock()]) --> AcquireGuard["调用 G::acquire()<br/> (如: 禁用中断)"]
AcquireGuard --> SMPCheck{"是否启用 SMP?"}
SMPCheck --> |是| TryLock["原子操作 compare_exchange<br/> 竞争锁状态"]
SMPCheck --> |否| CreateGuard["直接创建守卫对象"]
TryLock --> LockSuccess{成功?}
LockSuccess --> |是| CreateGuard
LockSuccess --> |否| SpinLoop["core::hint::spin_loop()<br/> 等待后重试"]
SpinLoop --> TryLock
CreateGuard --> ReturnGuard["返回 BaseSpinLockGuard"]
GuardScope(["守卫对象在作用域内"]) --> UseData["安全访问 *mut T 数据"]
GuardScope --> End([守卫对象离开作用域])
End --> DropGuard["调用 drop()"]
DropGuard --> ReleaseLock["(SMP) store(false)<br/> 释放锁状态"]
ReleaseLock --> RestoreState["调用 G::release()<br/> 恢复中断/抢占状态"]
RestoreState --> Finish([锁完全释放])
```

**Diagram sources**
- [src/base.rs](file://src/base.rs#L89-L145)
- [src/base.rs](file://src/base.rs#L388-L405)

**Section sources**
- [src/base.rs](file://src/base.rs#L89-L145)
- [src/base.rs](file://src/base.rs#L388-L405)

## 常见错误与最佳实践

### 选择正确的锁类型

选择错误的锁类型是常见的错误来源。请务必根据您的执行上下文进行选择：
- 如果您确定代码永远不会在中断处理程序中运行，并且上下文已经禁用了抢占和中断，请使用 `SpinRaw`。
- 如果您需要在普通内核线程中保护数据免受其他线程干扰，但允许中断发生，请使用 `SpinNoPreempt`。
- 如果您需要最高级别的安全性，或者不确定上下文状态，请始终使用 `SpinNoIrq`。

### 忘记引入必要trait

虽然 `kspin` 的核心类型是开箱即用的，但在某些复杂的同步场景下，可能需要从 `kernel_guard` 库中引入额外的trait。确保检查文档以了解是否有任何隐含的依赖。

### 误用非Send类型

尽管 `kspin` 本身